.\\" auto-generated by docbook2man-spec $Revision: 1.2 $
.TH "LXC.CONF" "5" "Wed Dec 7 15:14:08 CST 2011" "" ""
.SH NAME
lxc.conf \- linux container configuration file
.SH "DESCRIPTION"
.PP
The linux containers (\fBlxc\fR) are always created
before being used. This creation defines a set of system
resources to be virtualized / isolated when a process is using
the container. By default, the pids, sysv ipc and mount points
are virtualized and isolated. The other system resources are
shared across containers, until they are explicitly defined in
the configuration file. For example, if there is no network
configuration, the network will be shared between the creator of
the container and the container itself, but if the network is
specified, a new network stack is created for the container and
the container can no longer use the network of its ancestor.
.PP
The configuration file defines the different system resources to
be assigned for the container. At present, the utsname, the
network, the mount points, the root file system and the control
groups are supported.
.PP
Each option in the configuration file has the form \fBkey
= value\fR fitting in one line. The '#' character means
the line is a comment.
.SS "ARCHITECTURE"
.PP
Allows to set the architecture for the container. For example,
set a 32bits architecture for a container running 32bits
binaries on a 64bits host. That fix the container scripts
which rely on the architecture to do some work like
downloading the packages.
.TP
\fBlxc.arch\fR
Specify the architecture for the container.

Valid options are
\fBx86\fR,
\fBi686\fR,
\fBx86_64\fR,
\fBamd64\fR
.SS "HOSTNAME"
.PP
The utsname section defines the hostname to be set for the
container. That means the container can set its own hostname
without changing the one from the system. That makes the
hostname private for the container.
.TP
\fBlxc.utsname\fR
specify the hostname for the container
.SS "NETWORK"
.PP
The network section defines how the network is virtualized in
the container. The network virtualization acts at layer
two. In order to use the network virtualization, parameters
must be specified to define the network interfaces of the
container. Several virtual interfaces can be assigned and used
in a container even if the system has only one physical
network interface.
.TP
\fBlxc.network.type\fR
specify what kind of network virtualization to be used
for the container. Each time
a \fBlxc.network.type\fR field is found a new
round of network configuration begins. In this way,
several network virtualization types can be specified
for the same container, as well as assigning several
network interfaces for one container. The different
virtualization types can be:

\fBempty:\fR will create only the loopback
interface.

\fBveth:\fR a peer network device is created
with one side assigned to the container and the other
side is attached to a bridge specified by
the \fBlxc.network.link\fR\&. If the bridge is
not specified, then the veth pair device will be created
but not attached to any bridge. Otherwise, the bridge
has to be setup before on the
system, \fBlxc\fR won't handle any
configuration outside of the container. By
default \fBlxc\fR choose a name for the
network device belonging to the outside of the
container, this name is handled
by \fBlxc\fR, but if you wish to handle
this name yourself, you can tell \fBlxc\fR
to set a specific name with
the \fBlxc.network.veth.pair\fR option.

\fBvlan:\fR a vlan interface is linked with
the interface specified by
the \fBlxc.network.link\fR and assigned to
the container. The vlan identifier is specified with the
option \fBlxc.network.vlan.id\fR\&.

\fBmacvlan:\fR a macvlan interface is linked
with the interface specified by
the \fBlxc.network.link\fR and assigned to
the container.
\fBlxc.network.macvlan.mode\fR specifies the
mode the macvlan will use to communicate between
different macvlan on the same upper device. The accepted
modes are \fBprivate\fR, the device never
communicates with any other device on the same upper_dev (default),
\fBvepa\fR, the new Virtual Ethernet Port
Aggregator (VEPA) mode, it assumes that the adjacent
bridge returns all frames where both source and
destination are local to the macvlan port, i.e. the
bridge is set up as a reflective relay. Broadcast
frames coming in from the upper_dev get flooded to all
macvlan interfaces in VEPA mode, local frames are not
delivered locallay, or \fBbridge\fR, it
provides the behavior of a simple bridge between
different macvlan interfaces on the same port. Frames
from one interface to another one get delivered directly
and are not sent out externally. Broadcast frames get
flooded to all other bridge ports and to the external
interface, but when they come back from a reflective
relay, we don't deliver them again. Since we know all
the MAC addresses, the macvlan bridge mode does not
require learning or STP like the bridge module does.

\fBphys:\fR an already existing interface
specified by the \fBlxc.network.link\fR is
assigned to the container.
.TP
\fBlxc.network.flags\fR
specify an action to do for the
network.

\fBup:\fR activates the interface.
.TP
\fBlxc.network.link\fR
specify the interface to be used for real network
traffic.
.TP
\fBlxc.network.name\fR
the interface name is dynamically allocated, but if
another name is needed because the configuration files
being used by the container use a generic name,
eg. eth0, this option will rename the interface in the
container.
.TP
\fBlxc.network.hwaddr\fR
the interface mac address is dynamically allocated by
default to the virtual interface, but in some cases,
this is needed to resolve a mac address conflict or to
always have the same link-local ipv6 address
.TP
\fBlxc.network.ipv4\fR
specify the ipv4 address to assign to the virtualized
interface. Several lines specify several ipv4 addresses.
The address is in format x.y.z.t/m,
eg. 192.168.1.123/24. The broadcast address should be
specified on the same line, right after the ipv4
address.
.TP
\fBlxc.network.ipv6\fR
specify the ipv6 address to assign to the virtualized
interface. Several lines specify several ipv6 addresses.
The address is in format x::y/m,
eg. 2003:db8:1:0:214:1234:fe0b:3596/64
.TP
\fBlxc.network.script.up\fR
add a configuration option to specify a script to be
executed after creating and configuring the network used
from the host side. The following arguments are passed
to the script: container name and config section name
(net) Additional arguments depend on the config section
employing a script hook; the following are used by the
network system: execution context (up), network type
(empty/veth/macvlan/phys), Depending on the network
type, other arguments may be passed:
veth/macvlan/phys. And finally (host-sided) device name.
.SS "NEW PSEUDO TTY INSTANCE (DEVPTS)"
.PP
For stricter isolation the container can have its own private
instance of the pseudo tty.
.TP
\fBlxc.pts\fR
If set, the container will have a new pseudo tty
instance, making this private to it. The value specifies
the maximum number of pseudo ttys allowed for a pts
instance (this limitation is not implemented yet).
.SS "CONTAINER SYSTEM CONSOLE"
.PP
If the container is configured with a root filesystem and the
inittab file is setup to use the console, you may want to specify
where goes the output of this console.
.TP
\fBlxc.console\fR
Specify a path to a file where the console output will
be written. The keyword 'none' will simply disable the
console. This is dangerous once if have a rootfs with a
console device file where the application can write, the
messages will fall in the host.
.SS "CONSOLE THROUGH THE TTYS"
.PP
If the container is configured with a root filesystem and the
inittab file is setup to launch a getty on the ttys. This
option will specify the number of ttys to be available for the
container. The number of getty in the inittab file of the
container should not be greater than the number of ttys
specified in this configuration file, otherwise the excess
getty sessions will die and respawn indefinitly giving
annoying messages on the console.
.TP
\fBlxc.tty\fR
Specify the number of tty to make available to the
container.
.SS "MOUNT POINTS"
.PP
The mount points section specifies the different places to be
mounted. These mount points will be private to the container
and won't be visible by the processes running outside of the
container. This is useful to mount /etc, /var or /home for
examples.
.TP
\fBlxc.mount\fR
specify a file location in
the \fIfstab\fR format, containing the
mount informations. If the rootfs is an image file or a
device block and the fstab is used to mount a point
somewhere in this rootfs, the path of the rootfs mount
point should be prefixed with the
\fI/usr/local/lib/lxc/rootfs\fR default path or
the value of \fBlxc.rootfs.mount\fR if
specified.
.TP
\fBlxc.mount.entry\fR
specify a mount point corresponding to a line in the
fstab format.
.SS "ROOT FILE SYSTEM"
.PP
The root file system of the container can be different than that
of the host system.
.TP
\fBlxc.rootfs\fR
specify the root file system for the container. It can
be an image file, a directory or a block device. If not
specified, the container shares its root file system
with the host.
.TP
\fBlxc.rootfs.mount\fR
where to recursively bind \fBlxc.rootfs\fR
before pivoting. This is to ensure success of the
\fBpivot_root\fR(8)
syscall. Any directory suffices, the default should
generally work.
.TP
\fBlxc.pivotdir\fR
where to pivot the original root file system under
\fBlxc.rootfs\fR, specified relatively to
that. The default is \fImnt\fR\&.
It is created if necessary, and also removed after
unmounting everything from it during container setup.
.SS "CONTROL GROUP"
.PP
The control group section contains the configuration for the
different subsystem. \fBlxc\fR does not check the
correctness of the subsystem name. This has the disadvantage
of not detecting configuration errors until the container is
started, but has the advantage of permitting any future
subsystem.
.TP
\fBlxc.cgroup.[subsystem name]\fR
specify the control group value to be set. The
subsystem name is the literal name of the control group
subsystem. The permitted names and the syntax of their
values is not dictated by LXC, instead it depends on the
features of the Linux kernel running at the time the
container is started,
eg. \fBlxc.cgroup.cpuset.cpus\fR
.SS "CAPABILITIES"
.PP
The capabilities can be dropped in the container if this one
is run as root.
.TP
\fBlxc.cap.drop\fR
Specify the capability to be dropped in the container. A
single line defining several capabilities with a space
separation is allowed. The format is the lower case of
the capability definition without the "CAP_" prefix,
eg. CAP_SYS_MODULE should be specified as
sys_module. See
\fBcapabilities\fR(7),
.SH "EXAMPLES"
.PP
In addition to the few examples given below, you will find
some other examples of configuration file in /usr/local/share/doc/lxc/examples
.SS "NETWORK"
.PP
This configuration sets up a container to use a veth pair
device with one side plugged to a bridge br0 (which has been
configured before on the system by the administrator). The
virtual network device visible in the container is renamed to
eth0.
.sp
.nf
	lxc.utsname = myhostname
	lxc.network.type = veth
	lxc.network.flags = up
	lxc.network.link = br0
	lxc.network.name = eth0
	lxc.network.hwaddr = 4a:49:43:49:79:bf
	lxc.network.ipv4 = 1.2.3.5/24 1.2.3.255
	lxc.network.ipv6 = 2003:db8:1:0:214:1234:fe0b:3597
      
.sp
.fi
.SS "CONTROL GROUP"
.PP
This configuration will setup several control groups for
the application, cpuset.cpus restricts usage of the defined cpu,
cpus.share prioritize the control group, devices.allow makes
usable the specified devices.
.sp
.nf
	lxc.cgroup.cpuset.cpus = 0,1
	lxc.cgroup.cpu.shares = 1234
	lxc.cgroup.devices.deny = a
	lxc.cgroup.devices.allow = c 1:3 rw
	lxc.cgroup.devices.allow = b 8:0 rw
      
.sp
.fi
.SS "COMPLEX CONFIGURATION"
.PP
This example show a complex configuration making a complex
network stack, using the control groups, setting a new hostname,
mounting some locations and a changing root file system.
.sp
.nf
	lxc.utsname = complex
	lxc.network.type = veth
	lxc.network.flags = up
	lxc.network.link = br0
	lxc.network.hwaddr = 4a:49:43:49:79:bf
	lxc.network.ipv4 = 1.2.3.5/24 1.2.3.255
	lxc.network.ipv6 = 2003:db8:1:0:214:1234:fe0b:3597
	lxc.network.ipv6 = 2003:db8:1:0:214:5432:feab:3588
	lxc.network.type = macvlan
	lxc.network.flags = up
	lxc.network.link = eth0
	lxc.network.hwaddr = 4a:49:43:49:79:bd
	lxc.network.ipv4 = 1.2.3.4/24
	lxc.network.ipv4 = 192.168.10.125/24
	lxc.network.ipv6 = 2003:db8:1:0:214:1234:fe0b:3596
	lxc.network.type = phys
	lxc.network.flags = up
	lxc.network.link = dummy0
	lxc.network.hwaddr = 4a:49:43:49:79:ff
	lxc.network.ipv4 = 1.2.3.6/24
	lxc.network.ipv6 = 2003:db8:1:0:214:1234:fe0b:3297
	lxc.cgroup.cpuset.cpus = 0,1
	lxc.cgroup.cpu.shares = 1234
	lxc.cgroup.devices.deny = a
	lxc.cgroup.devices.allow = c 1:3 rw
	lxc.cgroup.devices.allow = b 8:0 rw
	lxc.mount = /etc/fstab.complex
	lxc.mount.entry = /lib /root/myrootfs/lib none ro,bind 0 0
	lxc.rootfs = /mnt/rootfs.complex
	lxc.cap.drop = sys_module mknod setuid net_raw
	lxc.cap.drop = mac_override
      
.sp
.fi
.SH "SEE ALSO"
.PP
\fBchroot\fR(1),
\fBpivot_root\fR(8),
\fB\fIfstab\fB\fR(5)
.SH "SEE ALSO"
.PP
\fBlxc\fR(1),
\fBlxc-create\fR(1),
\fBlxc-destroy\fR(1),
\fBlxc-start\fR(1),
\fBlxc-stop\fR(1),
\fBlxc-execute\fR(1),
\fBlxc-kill\fR(1),
\fBlxc-console\fR(1),
\fBlxc-monitor\fR(1),
\fBlxc-wait\fR(1),
\fBlxc-cgroup\fR(1),
\fBlxc-ls\fR(1),
\fBlxc-ps\fR(1),
\fBlxc-info\fR(1),
\fBlxc-freeze\fR(1),
\fBlxc-unfreeze\fR(1),
\fBlxc.conf\fR(5)
.SH "AUTHOR"
.PP
Daniel Lezcano <daniel.lezcano@free.fr>
